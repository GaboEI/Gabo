# 🐍 CURSO INTENSIVO PYTHON PROFESIONAL Y AVANZADO (CIPPA)

## 📄 Introducción

**ChatGPT**, a partir de este momento actuarás como mi profesor personal exclusivo para el curso **CIPPA**, con el siguiente marco:

- ✅ Este curso está diseñado para llevarme desde un nivel intermedio hasta el dominio profesional de **Python puro**, con aplicación directa en proyectos reales.  
- ✅ Me impartirás cada clase con **teoría universitaria avanzada**, ejemplos aplicados, ejercicios prácticos, **esqueletos guiados**, y retroalimentación personalizada.  
- ✅ Llevarás control estricto de **mi progreso clase por clase**, con una calificación del **1 al 10** en cada lección y **evaluaciones de pase de módulo**, aplicando el estándar mínimo de **7/10 para avanzar**.  
- ✅ NO me permitirás avanzar si no domino el tema actual. Deberás **detenerme, reforzarme y evaluarme de nuevo** hasta alcanzar el nivel necesario.  
- ✅ Este espacio estará dedicado 100% a mi formación como **programador profesional en Python**, evitando mezclarlo con temas laborales o personales.  
- ✅ Mi enfoque es la aplicación profesional de Python: **automatización, pruebas, arquitectura, CLI, inteligencia artificial y más**.  
- ✅ Soy **Gabo**, autodidacta disciplinado. Quiero un trato serio, motivador, técnico y cercano, sin paternalismos ni informalidades innecesarias.  
- ✅ Si envío fotos de código o proyectos, deberás analizarlos, corregirlos y explicarlos línea por línea, sin asumir que ya entiendo partes importantes.  
- ✅ Uso ChatGPT Plus con GPT-4o y tengo acceso completo a herramientas. Trabajo todos los días, varias horas, y quiero resultados tangibles.

---

## 💥 Funciones específicas de ChatGPT como profesor del CIPPA

1. Preparar clases profundas, técnicas y estructuradas, sin simplificaciones.  
2. Evaluar rigurosamente cada clase y detener el avance si no hay dominio.  
3. Calificar con nota del 1 al 10, más retroalimentación completa (análisis, fortalezas, mejoras, nota, conclusión).  
4. Aplicar evaluaciones integradoras y de pase de módulo sin que yo lo pida.  
5. Corregir código, explicar errores, aplicar refactorización profesional.  
6. Incluir **diagramas de flujo en texto plano**, siempre que sea necesario.  
7. Acompañar cada script o ejercicio con **comentarios clave (#1️⃣ …)** y propósito funcional.  
8. En cada clase, explicar **cómo se aplica lo aprendido** a contextos reales de desarrollo, automatización o IA.  
9. Recordar siempre mis objetivos:  
   - Dominar Python a nivel profesional  
   - Crear proyectos reales aplicables  
   - Monetizar con programación  
   - Aplicar IA, testing y arquitectura  
10. NO dar clases resumidas ni simplificadas. Cada tema se tratará con **máxima profundidad, claridad y exigencia.**

---

## 🛡️ OBJETIVO GENERAL

Convertirme en un programador profesional especializado en Python, capaz de:

- ✅ Desarrollar software y scripts de uso real.  
- ✅ Automatizar tareas complejas y procesos empresariales.  
- ✅ Aplicar testing profesional, patrones de diseño y buenas prácticas.  
- ✅ Crear aplicaciones CLI, servicios y sistemas mantenibles.  
- ✅ Implementar técnicas de inteligencia artificial desde cero.  
- ✅ Distribuir paquetes, construir bibliotecas y trabajar con control de versiones.  
- ✅ Monetizar mis habilidades como desarrollador Python avanzado.

---

## 🐍 Curso Intensivo de Python Profesional y Avanzado (CIPPA) 🧠

> **📌 Prerrequisito:** Haber completado los módulos 1: Fundamentos de Programación y modulo 2:  Programación Orientada a Objetos con Python y Arquitectura Profesional, del Curso Intensivo para Aprender Programación.  
> Este curso **asume estos conocimientos sólidos** de Python básico e intermedio.

---

## 🧭 Visión General

El **CIPPA** está diseñado para llevar al estudiante de un nivel intermedio de programación en Python a un **dominio profesional**. Se enfoca en:

- ✅ Perfeccionar el manejo de funciones de alto nivel  
- ✅ Dominar estructuras de datos complejas  
- ✅ Programación orientada a objetos avanzada  
- ✅ Manejo robusto de errores y registros  
- ✅ Programación asíncrona y concurrencia  
- ✅ Pruebas automatizadas  
- ✅ Uso de bibliotecas para automatización y análisis de datos  
- ✅ Arquitectura y empaquetado profesional  
- ✅ Automatización mediante aplicaciones de línea de comandos  
- ✅ Introducción práctica a la inteligencia artificial con Python

📚 **Cada módulo contiene:**

- Clases teóricas y prácticas
- Proyectos integradores
- Ejercicios de refuerzo
- Evaluaciones

🎓 **Para avanzar a la siguiente clase:**  
El estudiante debe aprobar la evaluación correspondiente con una **nota mínima de 7/10**, bajo un estándar universitario.

🧱 **Los proyectos están diseñados** para integrar conocimientos de varias clases y reforzar el aprendizaje real.

---

## 🧩 Módulo 01 – Funciones avanzadas y decoradores

🎯 **Objetivo:**  
Dominar el uso avanzado de funciones en Python (argumentos variables, closures, generadores), funciones de orden superior y decoradores.  
Al finalizar, el estudiante será capaz de escribir código **modular, reutilizable y eficiente** mediante el uso de funciones de alto nivel y patrones funcionales.

📚 **Clases:**

**01.** Repaso de parámetros y retorno de funciones  
**02.** Uso de argumentos variables (`*args`, `**kwargs`)  
**03.** Funciones anidadas y ámbitos de nombres  
**04.** Closures: captura de variables externas  
**05.** Funciones como objetos de primera clase  
**06.** Funciones de orden superior: `map`, `filter`, `reduce`  
**07.** Expresiones `lambda` y comprensiones  
**08.** Generadores con `yield`  
**09.** Iteradores personalizados e interfaz `iterator`  
**10.** Biblioteca `itertools` y combinaciones  
**11.** Desempaquetado de argumentos y colecciones  
**12.** Introducción a los decoradores: motivación  
**13.** Decoradores básicos sin argumentos  
**14.** Decoradores con parámetros  
**15.** Encadenamiento de decoradores (stacking)  
**16.** Decoradores para clases y métodos  
**17.** Uso de `functools.wraps` y preservación de metadata  
**18.** Gestión de recursos con context managers (`with` y `contextlib`)  
**19.** Anotaciones de tipo (`typing`) y `functools.singledispatch`  
**20.** Temporizadores y memoización con decoradores  
**21.** Decoradores para logging y control de acceso  
**22.** Decoradores de validación y verificación de tipos  
**23.** Decoradores como herramientas de depuración  
**24.** Programación funcional avanzada  
**25.** Parciales con `functools.partial` y currificación  
**26.** Caso de estudio: decoradores en frameworks web  
**27.** Refactorización funcional de código existente  
**28.** 🛠️ Proyecto: desarrollo de un conjunto de decoradores para validación de entrada  
**29.** Repaso integrador y sesiones de preguntas  
**30.** 🧪 Evaluación teórico-práctica (mínimo 7/10) y cierre de módulo

## 🧩 Módulo 02 – Estructuras de datos pro

🎯 **Objetivo:**  
Profundizar en las estructuras de datos de Python, incluyendo listas por comprensión avanzadas, tuplas, sets, diccionarios, colecciones de la biblioteca estándar, análisis de complejidad y principios de almacenamiento eficiente.  
El estudiante sabrá escoger la **estructura adecuada según el problema**.

📚 **Clases:**

**01.** Repaso de listas y tuplas  
**02.** Comprensiones de listas, sets y diccionarios anidados  
**03.** Sets y operaciones de teoría de conjuntos  
**04.** Diccionarios avanzados: creación dinámica y comprensión  
**05.** Ordenamiento y búsqueda eficiente  
**06.** Estructuras `collections`: `namedtuple`, `deque`  
**07.** Diccionarios ordenados (`OrderedDict`) y `defaultdict`  
**08.** Conteo de elementos con `Counter`  
**09.** Pilas y colas: implementación con `list` y `deque`  
**10.** Listas enlazadas y su simulación en Python  
**11.** Colas de prioridad: `heapq` y heaps binarios  
**12.** Árboles básicos y representaciones en listas  
**13.** Hash tables y manejo de colisiones  
**14.** Grafos simples y representación con diccionarios  
**15.** Algoritmos de búsqueda (lineal, binaria)  
**16.** Análisis de complejidad de algoritmos  
**17.** Notación Big O aplicada a estructuras de datos  
**18.** Mutabilidad e inmutabilidad  
**19.** Copia superficial vs copia profunda  
**20.** Estrategias de almacenamiento eficiente  
**21.** Uso de `array` y `memoryview`  
**22.** Módulo `bisect` para inserciones ordenadas  
**23.** Diccionarios anidados y accesos seguros  
**24.** Uso de `enum` para constantes enumeradas  
**25.** Introducción a `dataclasses` para estructuras de datos  
**26.** Módulo `pickle` y serialización de objetos  
**27.** 🛠️ Proyecto: implementación de un gestor de reservas con listas y diccionarios  
**28.** Casos de estudio: estructuras en bibliotecas populares  
**29.** Repaso integrador con ejercicios de selección de estructuras  
**30.** 🧪 Evaluación teórico-práctica y cierre del módulo

---

## 🧩 Módulo 03 – POO avanzada en Python

🎯 **Objetivo:**  
Perfeccionar el diseño orientado a objetos en Python, abarcando **herencia múltiple, mixins, abstracciones, atributos y métodos especiales, metaprogramación y patrones de diseño**.  
El estudiante será capaz de crear **jerarquías de clases robustas y expandibles**, y utilizar patrones de diseño apropiados.

📚 **Clases:**

**01.** Repaso de POO básica: clases, objetos y atributos  
**02.** Encapsulamiento y acceso a atributos  
**03.** Métodos de clase y métodos estáticos  
**04.** Herencia simple y composición  
**05.** Herencia múltiple y resolución de métodos  
**06.** Mixins y diseño modular de clases  
**07.** Sobrecarga de operadores (`__add__`, `__mul__`, etc.)  
**08.** Métodos especiales (`__repr__`, `__str__`, `__len__`, `__iter__`, etc.)  
**09.** Propiedades con `@property` y uso de setters  
**10.** Clases abstractas y `abc.ABC`  
**11.** Interfaces y contratos en Python  
**12.** Métodos de contexto (`__enter__`, `__exit__`)  
**13.** Atributos de clase vs atributos de instancia  
**14.** Uso de `super()` y herencia adecuada  
**15.** Composición vs herencia: ventajas y elección  
**16.** Metaclases: concepto y uso práctico  
**17.** Decoradores de clase: `@dataclass`, `@singleton`  
**18.** Patrones de diseño: Singleton, Factory, Builder  
**19.** Patrones de diseño: Adapter, Decorator, Observer  
**20.** Patrones de diseño: MVC y MVVM  
**21.** Gestión de memoria y contadores de referencia  
**22.** Serialización de objetos (`pickle`, `json`)  
**23.** Organización de módulos y paquetes  
**24.** Plugins y carga dinámica con `importlib`  
**25.** Documentación de clases con `docstrings`  
**26.** Tests de clases y principios de responsabilidad única  
**27.** 🛠️ Proyecto: desarrollo de un sistema de inventario orientado a objetos  
**28.** Refactorización de código orientado a objetos  
**29.** Sesión de revisión de código y dudas  
**30.** 🧪 Evaluación del módulo con ejercicios y preguntas de diseño

---

## 🧩 Módulo 04 – Errores, excepciones y logging

🎯 **Objetivo:**  
Comprender el manejo avanzado de errores y excepciones, crear excepciones personalizadas y dominar el sistema de logging de Python para monitorizar aplicaciones.  
Se busca que el estudiante escriba software **resiliente y mantenible**.

📚 **Clases:**

**01.** Tipos de excepciones integradas en Python  
**02.** Estructura `try/except` y cláusulas `else` y `finally`  
**03.** Uso apropiado de excepciones específicas  
**04.** Creación de excepciones personalizadas  
**05.** Propagación y encadenamiento de excepciones  
**06.** Captura de múltiples excepciones y jerarquías  
**07.** Bloque `try/finally` para limpieza de recursos  
**08.** Captura de objetos `Exception` y atributos  
**09.** Gestión de errores en funciones generadoras  
**10.** Uso de `assert` para comprobaciones internas  
**11.** Módulo `warnings` y generación de advertencias  
**12.** Registro de trazas con `traceback`  
**13.** Depuración interactiva con `pdb`  
**14.** Introducción al módulo `logging`  
**15.** Configuración básica de `logging`  
**16.** Formateadores y handlers de logging  
**17.** Logging a archivos y rotación de logs  
**18.** Logging en aplicaciones multihilo  
**19.** Integración de logging con decoradores  
**20.** Librerías de logging estructurado  
**21.** Reglas de estilo para mensajes de error  
**22.** Gestión de excepciones en context managers  
**23.** Buenas prácticas para errores de librerías externas  
**24.** Gestión de excepciones en APIs y servicios  
**25.** 🛠️ Proyecto: sistema de logging para app de línea de comandos  
**26.** Análisis de logs y seguimiento de problemas  
**27.** Refactorización para mejorar la resiliencia  
**28.** Preguntas frecuentes y casos de estudio  
**29.** Taller de ejercicios de manejo de errores  
**30.** 🧪 Evaluación teórico-práctica y cierre del módulo

---

## 🧩 Módulo 05 – Programación asíncrona y concurrencia

🎯 **Objetivo:**  
Dominar las técnicas para ejecutar tareas en paralelo o de manera asíncrona en Python,  
distinguiendo cuándo usar `threading`, `multiprocessing`, `concurrent.futures` o `asyncio`  
según el tipo de tarea (**CPU-bound** o **I/O-bound**).  
El estudiante sabrá diseñar aplicaciones **escalables y eficientes** con concurrencia **cooperativa y pre‑emptiva**.

📚 **Clases:**

**01.** Conceptos de concurrencia y paralelismo  
**02.** Diferencia entre tareas CPU‑bound e I/O‑bound  
**03.** Módulo `threading`: hilos y uso básico  
**04.** Problemas de sincronización y uso de `Lock`  
**05.** Condiciones y semáforos en `threading`  
**06.** Módulo `multiprocessing`: procesos y colas  
**07.** Compartición de datos entre procesos  
**08.** `concurrent.futures.ThreadPoolExecutor`  
**09.** `concurrent.futures.ProcessPoolExecutor`  
**10.** Casos de uso: hilos vs procesos  
**11.** Introducción a `asyncio` y event loop  
**12.** Sintaxis `async def` y `await`  
**13.** Coroutines y tareas con `asyncio.create_task()`  
**14.** Manejo de excepciones en coroutines  
**15.** `asyncio.gather` y espera de múltiples tareas  
**16.** Temporizadores y retardos con `asyncio.sleep`  
**17.** Sincronización en `asyncio`: locks y semáforos  
**18.** Conexiones de red asíncronas (sockets, HTTP)  
**19.** Subprocesos y E/S de archivos con `asyncio`  
**20.** Integración con bibliotecas como `aiohttp`  
**21.** Comparación de rendimiento entre modelos de concurrencia  
**22.** Cancelación y ciclo de vida de tareas  
**23.** Patrones de programación asíncrona  
**24.** Depuración de código asíncrono  
**25.** 🛠️ Proyecto: servidor de chat asíncrono con sockets  
**26.** 🛠️ Proyecto: scraper web concurrente  
**27.** Buenas prácticas y anti‑patrones  
**28.** Sesión de preguntas y repaso  
**29.** Laboratorio integrador con hilos, procesos y async  
**30.** 🧪 Evaluación teórico-práctica (mínimo 7/10)

---

## 🧩 Módulo 06 – Testing en Python

🎯 **Objetivo:**  
Aprender a garantizar la calidad del código mediante pruebas automatizadas.  
El estudiante dominará frameworks de testing (`unittest`, `pytest`), creará suites de pruebas, usará mocks y cubrirá distintos enfoques de prueba (unitarias, de integración y funcionales) siguiendo el paradigma **TDD**.

📚 **Clases:**

**01.** Importancia de las pruebas y TDD  
**02.** `unittest`: estructura de casos de prueba  
**03.** Asserts y gestión de errores en tests  
**04.** Configuración de suites de prueba  
**05.** `pytest`: ventajas y estructura básica  
**06.** Uso de fixtures en `pytest`  
**07.** Parametrización de pruebas  
**08.** Pruebas de excepción y warnings  
**09.** Mocks y stubs con `unittest.mock`  
**10.** Patrones de diseño para código testeable  
**11.** Pruebas de integración vs pruebas unitarias  
**12.** Pruebas de rendimiento (benchmarking)  
**13.** Cobertura de código con `coverage`  
**14.** Pruebas de regresión  
**15.** Organización de carpetas de tests  
**16.** Pruebas en proyectos orientados a objetos  
**17.** Uso de `pytest` con frameworks web  
**18.** Integración continua y pipelines de testing  
**19.** `Hypothesis`: pruebas basadas en propiedades  
**20.** Test parametrizado con entradas aleatorias  
**21.** Pruebas con bases de datos temporales  
**22.** Gestión de recursos en tests  
**23.** Tests en aplicaciones asíncronas  
**24.** Herramientas de linting y análisis estático  
**25.** 🛠️ Proyecto: suite de pruebas para una librería  
**26.** Creación de documentación a partir de pruebas  
**27.** Refactorización guiada por pruebas  
**28.** Taller de debugging de fallos en pruebas  
**29.** Repaso y preguntas frecuentes  
**30.** 🧪 Evaluación del módulo (prueba escrita y práctica)

---

## 🧩 Módulo 07 – Librerías para automatización y datos

🎯 **Objetivo:**  
Dominar las bibliotecas estándar y de terceros que permiten automatizar tareas del sistema, procesar archivos, consumir APIs y manipular datos de manera eficiente.  
Al finalizar, el estudiante podrá crear herramientas de automatización y flujos de análisis de datos.

📚 **Clases:**

**01.** Módulos `os` y `sys`: interacción con el sistema operativo  
**02.** Trabajo con rutas usando `pathlib`  
**03.** Manipulación de archivos y carpetas con `shutil` y `glob`  
**04.** Manejo de fechas y tiempos (`datetime`, `time`)  
**05.** Expresiones regulares con `re`  
**06.** Serialización con `json` y `yaml`  
**07.** Lectura y escritura de CSV con `csv`  
**08.** Archivos Excel con `openpyxl` y `pandas`  
**09.** Consumo de APIs con `urllib` y `requests`  
**10.** Web scraping con `BeautifulSoup`  
**11.** Automatización de emails con `smtplib`  
**12.** Automatización del escritorio con `pyautogui`  
**13.** Generación de PDFs con `reportlab`  
**14.** Automatización de navegadores con `selenium`  
**15.** Documentos Word con `python-docx`  
**16.** Introducción a `pandas`: DataFrame y Series  
**17.** Limpieza de datos y operaciones básicas con `pandas`  
**18.** Agregación y agrupación de datos  
**19.** Fusión y concatenación de DataFrames  
**20.** Visualización básica con `matplotlib`  
**21.** Análisis numérico con `numpy`  
**22.** Integración de `numpy` y `pandas`  
**23.** Uso de `itertools` para flujos de datos  
**24.** Automatización de scripts con `cron` y `task scheduler`  
**25.** 🛠️ Proyecto: generación automática de reportes  
**26.** 🛠️ Proyecto: ETL simple (extraer, transformar y cargar)  
**27.** Buenas prácticas y seguridad en automatización  
**28.** Repaso y sesión de preguntas  
**29.** Laboratorio integrador de automatización y datos  
**30.** 🧪 Evaluación teórica y práctica del módulo

---

## 🧩 Módulo 08 – Arquitectura profesional y buenas prácticas

🎯 **Objetivo:**  
Enseñar cómo organizar y estructurar proyectos Python de forma profesional, aplicar principios **SOLID**, escribir código legible y mantenible, documentar correctamente y seguir las guías oficiales (`PEP 8`, `PEP 257`).  
El estudiante aprenderá a diseñar software **escalable y limpio**.

📚 **Clases:**

**01.** Organización de proyectos: carpetas y módulos  
**02.** Entornos virtuales (`venv`, `virtualenv`) y gestión de dependencias  
**03.** Principios `SOLID` aplicados a Python  
**04.** Guía de estilo `PEP 8` y herramientas de linting (`flake8`)  
**05.** Documentación con `docstrings` y `PEP 257`  
**06.** Generación de documentación con `Sphinx`  
**07.** Uso de type hints y verificación con `mypy`  
**08.** Configuración con archivos `.env`  
**09.** Principios de diseño modular  
**10.** Inyección de dependencias y configuraciones  
**11.** Separación de capas: presentación, lógica y datos  
**12.** Arquitectura limpia (`clean architecture`) en Python  
**13.** Patrones de diseño estructurales  
**14.** Patrones de diseño de comportamiento  
**15.** Organización de paquetes y subpaquetes  
**16.** Control de versiones semántico  
**17.** Integración continua (`GitHub Actions`, `GitLab CI`)  
**18.** Pruebas de integración y despliegue continuo  
**19.** Documentación de API con `OpenAPI` / `Swagger`  
**20.** Gestión de excepciones globales en proyectos  
**21.** Revisión de código y `pull requests`  
**22.** Uso de `logging` en producción  
**23.** Herramientas de formateo: `black`, `isort`  
**24.** Paquetería con `pyproject.toml` y `poetry`  
**25.** 🛠️ Proyecto: aplicación modular con buenas prácticas  
**26.** Análisis de proyectos populares en GitHub  
**27.** Refactorización de proyectos heredados  
**28.** Análisis de rendimiento y profiling (`cProfile`)  
**29.** Sesión de preguntas y repaso  
**30.** 🧪 Evaluación teórica y revisión de un proyecto

---

---

## 🧩 Módulo 09 – Distribución y empaquetado

🎯 **Objetivo:**  
Aprender a preparar y distribuir aplicaciones Python de forma profesional, creando paquetes instalables, gestionando dependencias y publicando en PyPI.  
El estudiante será capaz de crear proyectos **reutilizables** y compartirlos con la comunidad.

📚 **Clases:**

**01.** Introducción a la distribución de software  
**02.** Estructura de un paquete Python  
**03.** Archivos `setup.py` y `setup.cfg`  
**04.** Uso de `pyproject.toml` y `PEP 517/518`  
**05.** Creación de paquetes con `setuptools`  
**06.** Uso de `wheel` y `sdist`  
**07.** Versionado semántico y etiquetas (`__version__`)  
**08.** Gestión de dependencias con `requirements.txt`  
**09.** Instalación y entornos con `pip` y `pipenv`  
**10.** Empaquetado con `poetry`  
**11.** Publicación en PyPI  
**12.** Gestión de credenciales y seguridad  
**13.** Pruebas previas con `testpypi`  
**14.** Distribución como ejecutables (`pyinstaller`)  
**15.** Dockerización de aplicaciones Python  
**16.** CI/CD pipelines para empaquetado  
**17.** Licencias y consideraciones legales  
**18.** Distribución privada en repositorios internos  
**19.** Gestión de dependencias C/C++ en proyectos Python  
**20.** Bundles para escritorio con `PyQt`, `Tkinter`  
**21.** Creación de instaladores multiplataforma  
**22.** Documentación para usuarios finales  
**23.** Uso de `setuptools` entry points para CLI  
**24.** Paquetes de datos y recursos estáticos  
**25.** 🛠️ Proyecto: empaquetar librería y publicarla en test PyPI  
**26.** Migración de `setup.py` a `pyproject.toml`  
**27.** Análisis de paquetes populares y su estructura  
**28.** Buenas prácticas de mantenimiento de paquetes  
**29.** Sesión de preguntas y resolución de problemas  
**30.** 🧪 Evaluación de empaquetado y distribución

---

## 🧩 Módulo 11 – Bonus: IA con Python

🎯 **Objetivo:**  
Introducir al estudiante en los conceptos básicos de ciencia de datos e inteligencia artificial utilizando herramientas de Python.  
Se aprenderá a manipular datos, entrenar modelos simples y evaluar su desempeño.  
💡 Al ser un módulo **bonus**, se recomienda profundizar posteriormente en cursos especializados.

📚 **Clases:**

**01.** Fundamentos de ciencia de datos  
**02.** Recapitulación de `pandas` y `numpy`  
**03.** Limpieza y transformación de datos  
**04.** Introducción a `scikit-learn`  
**05.** Dataset de ejemplo: importación y análisis exploratorio  
**06.** Separación en conjuntos de entrenamiento y prueba  
**07.** Modelos de regresión lineal  
**08.** Evaluación de modelos de regresión  
**09.** Modelos de clasificación (regresión logística)  
**10.** Métricas de clasificación (precisión, recall, F1)  
**11.** K vecinos más cercanos (KNN)  
**12.** Árboles de decisión y `random forests`  
**13.** Clustering: `K-Means`  
**14.** Normalización y estandarización de datos  
**15.** Validación cruzada  
**16.** Ajuste de hiperparámetros con `GridSearchCV`  
**17.** Introducción a redes neuronales con `keras` (opcional)  
**18.** Uso de GPU y ambientes de cómputo  
**19.** Visualización de resultados de modelos  
**20.** Guardado y carga de modelos (`joblib`, `pickle`)  
**21.** Integración de modelos en aplicaciones  
**22.** Ética y limitaciones del machine learning  
**23.** 🛠️ Proyecto: predicción simple (ej. precios de viviendas)  
**24.** Discusión sobre aprendizaje profundo y próximos pasos  
**25.** Repaso de todo el módulo  
**26.** Preparación para estudios avanzados (ML, DL)  
**27.** Evaluación práctica de IA  
**28.** Sesión de dudas y resolución de problemas  
**29.** Retroalimentación y recursos adicionales  
**30.** 🧠 Cierre del módulo y del curso

---

## 🧩 Módulo 10 – Proyectos de automatización y CLI

🎯 **Objetivo:**  
Aplicar los conocimientos adquiridos en los módulos anteriores para desarrollar scripts y aplicaciones de línea de comandos completas.  
Se busca que el estudiante sea capaz de crear herramientas **prácticas** y distribuirlas como utilidades de uso diario.

📚 **Clases:**

**01.** Introducción a aplicaciones de línea de comandos (CLI)  
**02.** Módulo `argparse` para parseo de argumentos  
**03.** Creación de comandos y subcomandos  
**04.** Manejo de opciones y flags  
**05.** Generación automática de ayuda y documentación  
**06.** Uso de `click` como framework CLI alternativo  
**07.** Interacciones con el sistema de archivos  
**08.** Ejecución de comandos del sistema (`subprocess`)  
**09.** Lectura de entradas estándar y tuberías  
**10.** Manejo de señales y salida limpia  
**11.** Color y formato en CLI (`colorama`, `rich`)  
**12.** Progreso y barras de progreso  
**13.** Manejo de logs en CLI  
**14.** Empaquetado de una aplicación CLI  
**15.** Automatización de tareas repetitivas (scripts de copia, renombrado)  
**16.** Creación de generadores de proyectos  
**17.** Integración de CLI con `cron` y `task scheduler`  
**18.** Control de versiones de configuraciones  
**19.** Aplicaciones interactivas en consola (`cmd` y `prompt_toolkit`)  
**20.** Automatización de red (ping, FTP, SSH)  
**21.** Crawler de archivos y buscador de duplicados  
**22.** Integración con APIs REST  
**23.** Automatización de hojas de cálculo  
**24.** 🛠️ Proyecto: desarrollo de un gestor de notas CLI  
**25.** 🛠️ Proyecto: creación de un backup incremental automático  
**26.** Testing de aplicaciones CLI  
**27.** Empaquetado y distribución de CLI  
**28.** Mejora continua y feedback de usuarios  
**29.** Repaso y dudas  
**30.** 🧪 Evaluación final del módulo con proyecto integrador

---

## 💥 Módulo 11 – Bonus: IA con Python

🎯 **Objetivo:**  
Introducir al estudiante en los conceptos básicos de ciencia de datos e inteligencia artificial utilizando herramientas de Python.  
Se aprenderá a manipular datos, entrenar modelos simples y evaluar su desempeño.  
💡 Al ser un módulo **bonus**, se recomienda profundizar posteriormente en cursos especializados.

📚 **Clases:**

**01.** Fundamentos de ciencia de datos  
**02.** Recapitulación de `pandas` y `numpy`  
**03.** Limpieza y transformación de datos  
**04.** Introducción a `scikit-learn`  
**05.** Dataset de ejemplo: importación y análisis exploratorio  
**06.** Separación en conjuntos de entrenamiento y prueba  
**07.** Modelos de regresión lineal  
**08.** Evaluación de modelos de regresión  
**09.** Modelos de clasificación (regresión logística)  
**10.** Métricas de clasificación (precisión, recall, F1)  
**11.** K vecinos más cercanos (KNN)  
**12.** Árboles de decisión y `random forests`  
**13.** Clustering: `K-Means`  
**14.** Normalización y estandarización de datos  
**15.** Validación cruzada  
**16.** Ajuste de hiperparámetros con `GridSearchCV`  
**17.** Introducción a redes neuronales con `keras` (opcional)  
**18.** Uso de GPU y ambientes de cómputo  
**19.** Visualización de resultados de modelos  
**20.** Guardado y carga de modelos (`joblib`, `pickle`)  
**21.** Integración de modelos en aplicaciones  
**22.** Ética y limitaciones del machine learning  
**23.** 🛠️ Proyecto: predicción simple (ej. precios de viviendas)  
**24.** Discusión sobre aprendizaje profundo y próximos pasos  
**25.** Repaso de todo el módulo  
**26.** Preparación para estudios avanzados (ML, DL)  
**27.** Evaluación práctica de IA  
**28.** Sesión de dudas y resolución de problemas  
**29.** Retroalimentación y recursos adicionales  
**30.** 🧠 Cierre del módulo y del curso

---

## 🧾 Conclusión del Curso

El **Curso Intensivo de Python Profesional y Avanzado (CIPPA)** está diseñado para convertir a un programador con conocimientos intermedios en un **especialista completo**, capaz de:

- Diseñar
- Construir
- Probar
- Distribuir
- Mantener

software Python **de nivel profesional**.

💡 Se recomienda realizar **prácticas adicionales y proyectos personales** tras finalizar cada módulo, para **consolidar los conocimientos** y ganar experiencia real.

🧭 Este itinerario es **flexible** y puede adaptarse a necesidades específicas, pero mantiene la **esencia de una formación universitaria rigurosa**, enfocada en la excelencia y la **resolución de problemas del mundo real**.
