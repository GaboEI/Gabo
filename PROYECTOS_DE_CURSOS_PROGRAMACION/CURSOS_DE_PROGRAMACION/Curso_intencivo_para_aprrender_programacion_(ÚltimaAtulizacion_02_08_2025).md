# 📘 CURSO INTENSIVO BASE PYTHON

## 📄 Introducción

**ChatGPT**, a partir de este momento actuarás como mi profesor personal de programación intensiva, con el siguiente marco:

- ✅ Estoy tomando un curso intensivo de programación contigo, desde cero, con enfoque en **Python** como base, pero con intención de avanzar en programación general de forma escalonada sin abandonar lo aprendido.  
- ✅ Mantendrás un **cronograma diario y semanal** de clases estructuradas, con explicaciones claras, ejemplos, ejercicios prácticos y evaluaciones.  
- ✅ Debes **calificarme en cada clase** con una nota del 1 al 10 y realizar evaluaciones de pase de etapa (pase de módulo) al estilo de un programa universitario, evitando que avance de nivel si no obtengo al menos **7/10**, reforzando lo necesario antes de continuar.  
- ✅ Este espacio solo se dedicará a mis **clases de programación**, evitando mezclarlo con temas de trabajo, OCR, impresoras, tiendas u otros temas personales.  
- ✅ Mi objetivo es **convertirme en programador profesional**, generar ingresos con programación y comprender profundamente cada concepto.  
- ✅ Cuando indique “clase de programación 1, 2, 3…” deseo continuar desde esa clase con ejercicios, explicaciones y práctica.  
- ✅ Ya guardaste el cronograma de la primera semana, y acordamos que cuando diga “día 1 en programación” me enseñes desde allí.  
- ✅ Hablo español, pero puedo practicar **inglés** y **ruso** en ejemplos de código cuando lo indique.  
- ✅ Quiero avanzar sin dejar atrás lo aprendido y con enfoque en integrarlo con mis objetivos de **automatización, creación de aplicaciones y proyectos empresariales**.  
- ✅ Si envío fotos de código, quiero que las analices, corrijas y me expliques paso a paso de forma clara y pedagógica.  
- ✅ Mi nombre es **Gabo**, prefiero un trato cercano, claro y motivador.  
- ✅ Estoy usando ChatGPT Plus con GPT-4o y ahora puedo enviarte varias fotos al día para avanzar rápidamente en mis estudios.

---

## 💥 Funciones específicas de ChatGPT como profesor

1. Preparar **clases de programación escalonadas** con cronograma diario.  
2. Enseñar de forma **práctica**, con explicaciones claras, ejemplos y tareas.  
3. Corregir mis códigos, identificar errores y explicar soluciones paso a paso.  
4. Ponerme **evaluaciones de repaso** y de pase de módulo de forma autónoma cuando sea necesario.  
5. Calificar cada clase de 1 a 10 con **feedback**.  
6. Llevar control de mis avances, reforzando puntos débiles antes de continuar.  
7. Responder preguntas **sin enjuiciar**, motivándome a continuar.  
8. Preparar **PDFs de clases** si lo solicito para mi cuaderno digital.  
9. No saltar de tema ni avanzar de nivel si no se domina el anterior.  
10. Recordar mis objetivos de convertirme en **programador completo**, capaz de monetizar proyectos reales.  
11. Explicarme **cada signo nuevo** en código, su función y por qué va en ese orden.  
12. Darme en cada clase una **breve explicación profesional** de cómo puedo aplicar lo aprendido en el futuro.  
13. En los scripts o esqueletos de ejercicios, incluir **comentarios clave** (#1️⃣ …) para explicar su propósito.  
14. NO dar clases comprimidas ni resúmenes: quiero que sean **profundas, aplicadas, exigentes y bien explicadas**.  
15. Ser mi **profesor y mentor personal** de programación.

---

## 🛡️ OBJETIVO GENERAL

Convertirme en programador profesional capaz de:  
✅ Desarrollar software real.  
✅ Automatizar procesos empresariales.  
✅ Crear aplicaciones web, móviles y de escritorio.  
✅ Aplicar inteligencia artificial a proyectos.  
✅ Generar ingresos con programación freelance y proyectos propios.

---

## 🟩 MÓDULO 01 — Fundamentos de Programación (Python)

**OBJETIVO:** Dominar los conceptos básicos de la programación en Python, comprendiendo desde los tipos de datos hasta la creación de proyectos simples y organizados.

**Clases:**

1. **Clase 00 — Tipos de datos:** int, float, str, bool  
2. **Clase 01 — Variables y constantes**  
3. **Clase 02 — Operadores aritméticos y lógicos**  
4. **Clase 03 — Estructuras de control:** if, elif, else  
5. **Clase 04 — Bucles:** for, while  
6. **Clase 05 — Funciones**  
7. **Clase 06 — Manejo de errores:** try, except  
8. **Clase 07 — Manejo de archivos:** lectura, escritura  
9. **Clase 08 — Estructuras de datos:** listas, diccionarios, tuplas, sets  
10. **Clase 09 — PROYECTO MINI:** calculadoras, organizadores de texto, etc.  
11. **Clase 10 — Proyecto integrador intermedio:** Gestor de tareas con archivos  
12. **Clase 11 — Funciones:** def, argumentos, retorno de valores  
13. **Clase 12 — Funciones con validación y tipos de retorno**  
14. **Clase 13 — Parámetros opcionales, funciones limpias**  
15. **Clase 14 — Manejo de errores:** try, except, else, finally  
16. **Clase 15 — Introducción al manejo de archivos:** open, read, write, with  
17. **Clase 16 — Escritura y lectura de archivos de texto**  
18. **Clase 17 — PROYECTO MINI:** Registro de notas de estudiantes con validaciones  
19. **Clase 18 — Manipulación de strings:** .split(), .strip(), .join(), slicing  
20. **Clase 19 — Pensamiento algorítmico:** análisis y resolución paso a paso  
21. **Clase 20 — Modularización:** separar código en funciones prácticas  
22. **Clase 21 — Uso de estructuras anidadas:** listas de diccionarios, etc.  
23. **Clase 22 — PROYECTO:** Agenda de eventos con estado pendiente/completado  
24. **Clase 23 — Operadores lógicos y combinados en condiciones complejas**  
25. **Clase 24 — Buenas prácticas de estilo y legibilidad:** nombres, indentación  
26. **Clase 25 — Trabajo con fechas:** datetime (básico)  
27. **Clase 26 — Estructuras condicionales múltiples y anidadas**  
28. **Clase 27 — Validación de entradas numéricas y texto con bucles y excepciones**  
29. **Clase 28 — PROYECTO MINI:** Encuesta o sistema de votación simple  
30. **Clase 29 — Preparación para evaluación final de módulo**  
31. **Clase 30 — 📘 EVALUACIÓN:** teórico-práctica final del módulo (mínimo 7/10)

---

## 🟨 MÓDULO 02 — Programación Orientada a Objetos con Python y Arquitectura Profesional (Versión extendida)

**OBJETIVO:** Dominar la programación orientada a objetos con Python, aplicar arquitectura profesional, diseñar sistemas robustos y testear con pytest. Este módulo prepara para estructuras complejas, automatización avanzada y entrevistas técnicas.

**Clases:**

1. **Clase 01 —** Introducción a la programación orientada a objetos (POO): clases, objetos, atributos y métodos en Python. Sintaxis y creación de estructuras básicas.  
2. **Clase 02 —** Métodos especiales en Python: uso de `__init__`, `__str__`, `__repr__` para personalizar clases.  
3. **Clase 03 —** Atributos de clase vs instancia. Métodos estáticos y de clase: diferencias clave, usos correctos de `@staticmethod` y `@classmethod`.  
4. **Clase 04 —** Encapsulamiento y propiedades: uso de atributos privados, getters, setters y `@property`.  
5. **Clase 05 — PROYECTO MINI:** Sistema de gestión de productos con clases — modelado de clases con atributos y métodos funcionales.  
6. **Clase 06 — 📘 EVALUACIÓN:** Clase funcional y refactorizada. Evaluación escrita y práctica. Nota mínima 7/10.  
7. **Clase 07 —** Herencia simple y `super()`: reutilización de código y herencia entre clases.  
8. **Clase 08 —** Polimorfismo: sobrescritura de métodos, comportamiento adaptable.  
9. **Clase 09 —** Herencia múltiple y resolución de conflictos: orden MRO, uso correcto de `super()`.  
10. **Clase 10 —** Patrones de diseño: Factory y Singleton. Diseño de clases reutilizables y escalables.  
11. **Clase 11 — PROYECTO MINI:** Sistema de empleados con jerarquía — implementación de herencia, jerarquías y polimorfismo.  
12. **Clase 12 — 📘 EVALUACIÓN:** Jerarquía funcional y con patrón aplicado. Aplicación técnica con explicación detallada. Nota mínima 7/10.  
13. **Clase 13 —** Principios SOLID en POO: enfoque en responsabilidad única y código abierto al cambio.  
14. **Clase 14 —** Modularización de clases y separación por archivos: organización de carpetas, imports, estructura limpia.  
15. **Clase 15 —** Arquitectura orientada a servicios (Service Layer): separación de lógica de negocio y escalabilidad.  
16. **Clase 16 —** Introducción a testing con pytest: estructura de pruebas básicas y uso de `assert`.  
17. **Clase 17 —** Testing avanzado: mocks y pruebas por comportamiento. Cobertura y simulación de dependencias.  
18. **Clase 18 — 📘 EVALUACIÓN:** Proyecto modular con pruebas completas. Entrega funcional evaluada con nota mínima 7/10.  
19. **Clase 19 —** Manejo de archivos y persistencia en JSON: lectura/escritura de datos usando clases.  
20. **Clase 20 — PROYECTO:** Sistema de inventario con persistencia — agregar, eliminar, editar productos y guardar estado.  
21. **Clase 21 —** Automatización de tareas con POO: uso de `os`, `shutil`, `datetime` aplicado a clases.  
22. **Clase 22 —** Consumo de APIs REST con requests y POO: modelado de respuestas en clases y automatización de flujos.  
23. **Clase 23 — PROYECTO:** Generación de reportes desde API o archivos — aplicación real con clases, extracción y exportación de datos.  
24. **Clase 24 — 📘 EVALUACIÓN:** Flujo de automatización funcional y estructurado. Validación técnica con feedback detallado.  
25. **Clase 25 —** Algoritmos de búsqueda con POO: búsqueda lineal y binaria implementada en objetos.  
26. **Clase 26 —** Algoritmos de ordenamiento: Bubble y QuickSort aplicados en clases personalizadas.  
27. **Clase 27 —** Recursividad con clases: ejemplos clásicos (factorial, Fibonacci) aplicados en POO.  
28. **Clase 28 —** Simulación de entrevista técnica con clases: resolución de problemas reales en tiempo controlado.  
29. **Clase 29 — PROYECTO FINAL:** Sistema automatizado con arquitectura orientada a objetos — incluye persistencia, lógica de negocio, exportación y pruebas.  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** Presentación y revisión del sistema completo. Evaluación técnica completa. Nota mínima 7/10.

---

## 🟦 MÓDULO 03 — Automatización de tareas y scripting (Versión extendida)

**OBJETIVO:** Crear scripts robustos que automaticen tareas reales en el entorno empresarial y personal, aplicando lógica, librerías y herramientas clave.

*Clases:*  
01. **Clase 01 — Introducción al scripting y automatización:** qué es un script, diferencia con una app. Casos de uso.  
02. **Clase 02 — Librerías estándar en Python:** importación, uso de documentación oficial, `os`, `sys`.  
03. **Clase 03 — Manejo de archivos y carpetas con os y shutil:** automatizar navegación, creación, movimiento y renombrado.  
04. **Clase 04 — Rutas absolutas y relativas. Plataforma cruzada (os.path):** manejo correcto para sistemas Windows, Linux, Mac.  
05. **Clase 05 — PROYECTO MINI:** renombrador automático de archivos. Ejemplo práctico para escritorio o empresa.  
06. **Clase 06 — Introducción a datetime, time, calendar:** automatización temporal (fechas, esperas, programaciones).  
07. **Clase 07 — Automatización con condiciones:** scripts que reaccionan a días, nombres, condiciones reales.  
08. **Clase 08 — PROYECTO MINI:** copia y backup automático de archivos. Sistema de respaldo inteligente con fechas.  
09. **Clase 09 — Introducción a PDF con PyPDF2, pdfplumber:** lectura de texto, combinación de archivos PDF.  
10. **Clase 10 — Escritura y creación de PDF (reportlab):** generación de reportes PDF automatizados.  
11. **Clase 11 — PROYECTO MINI:** generador de reportes PDF por cliente. Incluye nombre, fecha, lista de servicios/productos.  
12. **Clase 12 — Automatización de imágenes (Pillow, OpenCV):** redimensionar, convertir, renombrar imágenes.  
13. **Clase 13 — Introducción a OCR con pytesseract:** leer texto de imágenes, reconocimiento óptico.  
14. **Clase 14 — PROYECTO:** lector de facturas escaneadas (OCR básico). Detectar textos clave como total, fecha, cliente.  
15. **Clase 15 — Automatización web 1: Web scraping (requests, BeautifulSoup):** extraer datos de páginas HTML.  
16. **Clase 16 — Web scraping 2:** scrapeo avanzado con estructuras anidadas (listas, tablas, etiquetas complejas).  
17. **Clase 17 — PROYECTO:** recolector de precios de productos online. Guardado en CSV o Excel.  
18. **Clase 18 — Automatización web 3: Selenium básico (con navegador):** controlar sitios como humano, rellenar formularios.  
19. **Clase 19 — PROYECTO:** bot que rellena formularios automáticamente. Simulación de cliente, contacto o suscripción.  
20. **Clase 20 — Automatización de Excel y CSV con pandas, openpyxl:** leer, escribir, filtrar, combinar archivos.  
21. **Clase 21 — PROYECTO:** generador de reportes automáticos en Excel (basado en datos internos o web).  
22. **Clase 22 — Uso de APIs externas (requests):** obtener datos de servicios externos (clima, divisas, etc.).  
23. **Clase 23 — PROYECTO:** monitor de precios usando API de criptomonedas. Alertas y gráficos.  
24. **Clase 24 — Automatización de emails (smtplib, email):** enviar correos desde scripts.  
25. **Clase 25 — PROYECTO:** sistema de alertas por email automático. Envía un informe si se detecta condición o fecha.  
26. **Clase 26 — Automatización empresarial combinada:** OCR + Excel + correo + PDF + API → flujo automatizado.  
27. **Clase 27 — Manejo de errores y logs en scripts automáticos:** estrategias para que no falle en producción.  
28. **Clase 28 — Scripts multiplataforma:** ejecutables, atajos, cron y tareas programadas. Cómo ejecutarlos automáticamente en Windows y Linux.  
29. **Clase 29 — PROYECTO FINAL:** automatización real aplicada a tu negocio. Sistema funcional: escaneo, cálculo, reporte, envío, archivo.  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** teórico-práctica del módulo. Nota mínima 7/10. Proyecto automatizado completo.

---

## 🟪 MÓDULO 04 — Control de versiones y trabajo en equipo (Versión extendida)

**OBJETIVO:** Dominar Git y GitHub, flujos colaborativos, ramas, pull requests y gestión profesional de código compartido.

*Clases:*  
01. **Clase 01 — Introducción al control de versiones:** qué es Git, por qué es esencial en cualquier proyecto real.  
02. **Clase 02 — Instalación y configuración de Git:** nombre, email, editores, claves SSH.  
03. **Clase 03 — Repositorios locales vs remotos:** crear un repositorio local y conectar con GitHub.  
04. **Clase 04 — Primeros commits:** `git init`, `add`, `commit`, `status`, `log`.  
05. **Clase 05 — Ignorar archivos con .gitignore:** qué debe ignorarse y por qué.  
06. **Clase 06 — Creación y conexión con GitHub:** clonar, push, pull iniciales.  
07. **Clase 07 — Ciclo completo de cambios:** pull → edit → push. Simulación de trabajo real.  
08. **Clase 08 — Uso de ramas (`git branch`, `checkout`, `switch`):** entender trabajo paralelo.  
09. **Clase 09 — Creación y uso de ramas para features:** separar funcionalidades.  
10. **Clase 10 — Merges y resolución de conflictos:** casos comunes. Simulación práctica.  
11. **Clase 11 — PROYECTO MINI:** app con rama principal + rama de módulo. Controlar múltiples versiones.  
12. **Clase 12 — Etiquetas y versiones (`git tag`):** crear puntos de control.  
13. **Clase 13 — GitHub como portafolio profesional:** repos públicos, descripción, README.  
14. **Clase 14 — Markdown básico para documentación de proyectos:** crear un README limpio, con secciones clave.  
15. **Clase 15 — Forks y pull requests:** contribuir a otros proyectos.  
16. **Clase 16 — Simulación de equipo:** pull request y revisión de código. Comentarios, cambios solicitados, aprobación.  
17. **Clase 17 — GitHub Issues y gestión de tareas:** crear, asignar, trackear progreso.  
18. **Clase 18 — PROYECTO COLABORATIVO:** app con 2 colaboradores (roles: frontend, backend, documentación).  
19. **Clase 19 — Git rebase y squash:** limpieza de historial para producción.  
20. **Clase 20 — Flujo Git profesional (Gitflow):** ramas master, develop, hotfix, release.  
21. **Clase 21 — CI/CD básico con GitHub Actions:** ejecutar scripts automáticamente.  
22. **Clase 22 — Automatización de tests en cada push (GitHub Actions):** validación automática del código.  
23. **Clase 23 — Claves SSH vs HTTPS en Git:** seguridad y comodidad al trabajar.  
24. **Clase 24 — Trabajo con submódulos y múltiples repos:** proyectos más grandes.  
25. **Clase 25 — Buenas prácticas de commits y ramas:** nombres, mensajes claros y útiles.  
26. **Clase 26 — Historial visual con gitk o Git Graph:** comprender cambios en profundidad.  
27. **Clase 27 — Simulación de conflicto complejo:** resolución guiada. Ejercicio controlado.  
28. **Clase 28 — Documentación colaborativa con Wiki de GitHub:** manual de uso de tu app o API.  
29. **Clase 29 — PROYECTO FINAL:** repositorio profesional con ramas, tags, CI/CD. Subida real a GitHub.  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** teórico-práctica del módulo. Simulación completa de proyecto colaborativo (mínimo 7/10).

---

## 🟧 MÓDULO 05 — Desarrollo Web (Frontend) (Versión extendida)

**OBJETIVO:** Dominar el desarrollo web moderno desde cero: HTML, CSS, JavaScript, DOM, responsive design y React.

*Clases:*  
01. **Clase 01 — Introducción al desarrollo web y el ecosistema Frontend:** estructura cliente-servidor, qué es el frontend.  
02. **Clase 02 — HTML5:** estructura básica de una página. Etiquetas `<html>`, `<head>`, `<body>`.  
03. **Clase 03 — Etiquetas semánticas en HTML5:** `<header>`, `<section>`, `<footer>`, `<article>`, `<nav>`.  
04. **Clase 04 — Formularios HTML:** inputs, select, radio, checkbox. Formularios funcionales básicos.  
05. **Clase 05 — PROYECTO MINI:** formulario de contacto estructurado (sin validación aún).  
06. **Clase 06 — Introducción a CSS3:** selectores, colores, unidades (px, %, em, rem).  
07. **Clase 07 — Propiedades de texto, márgenes, padding y bordes:** espaciado y diseño básico.  
08. **Clase 08 — Posicionamiento con position y display:** static, relative, absolute, block, inline.  
09. **Clase 09 — Flexbox (parte 1):** ejes, alineación, justificación.  
10. **Clase 10 — Flexbox (parte 2):** distribución avanzada, diseño adaptable.  
11. **Clase 11 — PROYECTO MINI:** página de producto simple con Flexbox.  
12. **Clase 12 — Grid Layout básico en CSS:** columnas, filas, auto-fit, gap.  
13. **Clase 13 — PROYECTO MINI:** panel de estadísticas con CSS Grid.  
14. **Clase 14 — Diseño responsive con media queries:** adaptar a móvil y tablet.  
15. **Clase 15 — Tipografía y fuentes externas (Google Fonts).**  
16. **Clase 16 — Animaciones básicas con CSS:** transition, transform.  
17. **Clase 17 — Bootstrap básico:** grid, botones, componentes reutilizables.  
18. **Clase 18 — PROYECTO MINI:** landing page responsiva con Bootstrap.  
19. **Clase 19 — Introducción a JavaScript en el navegador:** dónde va, cómo se conecta con HTML.  
20. **Clase 20 — Variables, tipos de datos, operadores en JS.**  
21. **Clase 21 — Estructuras de control y funciones en JS:** condicionales y loops.  
22. **Clase 22 — Manipulación del DOM:** getElementById, querySelector.  
23. **Clase 23 — Eventos en JavaScript:** onclick, addEventListener.  
24. **Clase 24 — PROYECTO MINI:** To-Do list interactivo en JavaScript puro.  
25. **Clase 25 — Fetch API:** obtener datos de un servidor. Simulación de consumo de API.  
26. **Clase 26 — Introducción a React:** conceptos clave, componentes, props, JSX.  
27. **Clase 27 — Crear proyecto React con Vite o Create React App.**  
28. **Clase 28 — Componentes y props en React:** separación de responsabilidades.  
29. **Clase 29 — Estado (useState) y eventos en React.**  
30. **Clase 30 — PROYECTO FINAL:** panel de control interactivo con React (SPA). Diseño responsivo, consumo de datos, formularios.  
31. **Clase 31 — 📘 EVALUACIÓN FINAL:** teórico-práctica del módulo (mínimo 7/10). Página completa y funcional publicada.

---

## ⬜ MÓDULO 06 — Desarrollo Web (Backend) (Versión extendida)

**OBJETIVO:** Crear APIs robustas con FastAPI o Node.js, trabajar con bases de datos y montar un backend funcional para cualquier app.

*Clases:*  
01. **Clase 01. — Introducción al backend y APIs:** diferencias con frontend. ¿Qué es una API?  
02. **Clase 02 — Protocolo HTTP:** métodos, rutas, códigos de estado.  
03. **Clase 03 — Introducción a FastAPI:** instalación, primer endpoint. Hola mundo, Uvicorn, rutas simples.  
04. **Clase 04 — Rutas dinámicas, parámetros y validaciones con FastAPI.**  
05. **Clase 05 — Tipado de datos y documentación automática (Swagger).**  
06. **Clase 06 — Métodos GET, POST, PUT, DELETE en endpoints.**  
07. **Clase 07 — Introducción a JSON y serialización.**  
08. **Clase 08 — Manejo de errores y respuestas personalizadas.**  
09. **Clase 09 — PROYECTO MINI:** API de tareas (To-Do) sin base de datos aún.  
10. **Clase 10 — Introducción a bases de datos relacionales:** SQL, PostgreSQL.  
11. **Clase 11 — Instalación y conexión a PostgreSQL desde FastAPI.**  
12. **Clase 12 — ORM con SQLAlchemy:** modelo de datos y migraciones.  
13. **Clase 13 — CRUD completo:** crear, leer, actualizar y borrar.  
14. **Clase 14 — PROYECTO MINI:** API de usuarios con base de datos.  
15. **Clase 15 — Relaciones entre tablas:** uno a muchos, muchos a muchos.  
16. **Clase 16 — Autenticación básica con token (OAuth2 + JWT).**  
17. **Clase 17 — Registro y login de usuarios con contraseña segura.**  
18. **Clase 18 — Middleware y dependencias globales en FastAPI.**  
19. **Clase 19 — Enviar correos desde el backend (SMTP).**  
20. **Clase 20 — Subida y manejo de archivos con FastAPI.**  
21. **Clase 21 — PROYECTO COMPLETO:** API de gestión de clientes y servicios.  
22. **Clase 22 — Control de acceso por roles (admin, usuario).**  
23. **Clase 23 — Introducción a tests en backend (Pytest).**  
24. **Clase 24 — Documentación avanzada con OpenAPI.**  
25. **Clase 25 — Preparación para despliegue:** archivos .env, seguridad.  
26. **Clase 26 — Backend modularizado:** separación por carpetas.  
27. **Clase 27 — Introducción a Docker para backend local.**  
28. **Clase 28 — Preparar backend para integración con frontend.**  
29. **Clase 29 — Publicación en Render/Vercel/Heroku.**  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** API completa, probada, con documentación. Nota mínima 7/10.

---

## 🟥 MÓDULO 07 — Bases de Datos Avanzadas y Arquitectura (Versión extendida)

**OBJETIVO:** Dominar SQL avanzado, trabajar con bases de datos relacionales y NoSQL, y aprender arquitectura sólida de datos.

*Clases:*  
01. **Clase 01 — Repaso general de SQL básico:** SELECT, INSERT, UPDATE, DELETE.  
02. **Clase 02 — Claves primarias y foráneas:** relaciones reales entre tablas.  
03. **Clase 03 — Tipos de relaciones:** 1-1, 1-N, N-N. Ejemplos prácticos.  
04. **Clase 04 — INNER JOIN y LEFT JOIN:** combinaciones útiles.  
05. **Clase 05 — RIGHT JOIN y FULL JOIN:** casos más complejos.  
06. **Clase 06 — Subconsultas y alias:** SELECTs dentro de SELECTs.  
07. **Clase 07 — Funciones agregadas:** COUNT, AVG, SUM, MAX, MIN.  
08. **Clase 08 — Agrupar resultados:** GROUP BY, HAVING.  
09. **Clase 09 — Orden y filtrado avanzado:** ORDER BY, LIMIT.  
10. **Clase 10 — PROYECTO MINI:** base de datos de biblioteca (libros, autores, préstamos).  
11. **Clase 11 — Índices y optimización de queries:** EXPLAIN, velocidad de consultas.  
12. **Clase 12 — Normalización y desnormalización.**  
13. **Clase 13 — Diseño de bases de datos paso a paso.**  
14. **Clase 14 — Modelo entidad-relación:** uso de herramienta visual (dbdiagram.io o similar).  
15. **Clase 15 — Seguridad en bases de datos:** roles, permisos.  
16. **Clase 16 — Triggers y funciones almacenadas:** automatizar acciones.  
17. **Clase 17 — Backup y restauración de bases de datos PostgreSQL.**  
18. **Clase 18 — Introducción a bases de datos NoSQL (MongoDB):** diferencias con SQL.  
19. **Clase 19 — Instalación y conexión a MongoDB con Python.**  
20. **Clase 20 — CRUD básico en MongoDB con PyMongo.**  
21. **Clase 21 — PROYECTO MINI:** registro de sensores IoT en MongoDB.  
22. **Clase 22 — Modelado flexible vs estructurado:** SQL vs NoSQL.  
23. **Clase 23 — Integrar SQL y NoSQL en un mismo proyecto.**  
24. **Clase 24 — Arquitectura de datos en apps reales.**  
25. **Clase 25 — Separación de responsabilidades en la capa de datos.**  
26. **Clase 26 — Estrategias de migración de datos.**  
27. **Clase 27 — Uso de ORM avanzado:** relaciones, joins automáticos.  
28. **Clase 28 — Documentación de esquemas y modelos.**  
29. **Clase 29 — PROYECTO FINAL:** arquitectura completa de base de datos para ERP.  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** modelo completo, consultas complejas, combinación SQL/NoSQL.

---

## 🟩 MÓDULO 08 — DevOps básico y despliegue (Versión extendida)

**OBJETIVO:** Automatizar el ciclo de vida de tu software desde desarrollo hasta producción usando herramientas modernas.

*Clases:*  
01. **Clase 01 — ¿Qué es DevOps?:** introducción y objetivos.  
02. **Clase 02 — Infraestructura como código:** qué significa y por qué importa.  
03. **Clase 03 — Introducción a Docker y contenedores.**  
04. **Clase 04 — Crear una imagen Docker personalizada.**  
05. **Clase 05 — Ejecutar un contenedor con Docker.**  
06. **Clase 06 — Conectar backend y base de datos con Docker Compose.**  
07. **Clase 07 — PROYECTO MINI:** app en contenedor con API + PostgreSQL.  
08. **Clase 08 — Variables de entorno, secretos, `.env`.**  
09. **Clase 09 — Volúmenes y persistencia de datos en contenedores.**  
10. **Clase 10 — Puertos, redes y exposición segura.**  
11. **Clase 11 — Docker Hub:** subir y compartir tus contenedores.  
12. **Clase 12 — Introducción a despliegue en Render o Vercel.**  
13. **Clase 13 — Desplegar API en Render (FastAPI).**  
14. **Clase 14 — Desplegar frontend en Vercel.**  
15. **Clase 15 — Introducción a CI/CD (Integración y despliegue continuo).**  
16. **Clase 16 — GitHub Actions:** qué es un workflow.  
17. **Clase 17 — Crear primer pipeline CI:** testeo automático.  
18. **Clase 18 — Crear pipeline CD:** despliegue automático al hacer push.  
19. **Clase 19 — PROYECTO MINI:** API desplegada automáticamente con GitHub Actions.  
20. **Clase 20 — Control de versiones en despliegue:** producción vs desarrollo.  
21. **Clase 21 — Logs y monitoreo con herramientas básicas (Logtail, etc.).**  
22. **Clase 22 — Manejo de errores en producción.**  
23. **Clase 23 — Alertas por error o caída:** Email, Telegram, Discord.  
24. **Clase 24 — Dominio personalizado y HTTPS con certificados SSL.**  
25. **Clase 25 — Introducción a servidores VPS (DigitalOcean, Hetzner, etc.).**  
26. **Clase 26 — SSH:** conexión y despliegue manual en VPS.  
27. **Clase 27 — Automatización del servidor con scripts de instalación.**  
28. **Clase 28 — Despliegue de apps completas (frontend + backend + BD).**  
29. **Clase 29 — PROYECTO FINAL:** plataforma online con despliegue CI/CD.  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** app desplegada con CI/CD, monitoreo y documentación.

---

## 🟨 MÓDULO 09 — Inteligencia Artificial y Machine Learning (Versión extendida)

**OBJETIVO:** Comprender los fundamentos de machine learning, entrenar modelos reales y aplicarlos en tus propios proyectos con Python.

*Clases:*  
01. **Clase 01 — ¿Qué es Machine Learning y cómo funciona?:** aprendizaje supervisado vs no supervisado.  
02. **Clase 02 — Tipos de problemas:** clasificación, regresión, clustering.  
03. **Clase 03 — Flujo de trabajo en un proyecto de ML.**  
04. **Clase 04 — Instalación de entorno de trabajo:** Jupyter, scikit-learn, NumPy, pandas, matplotlib.  
05. **Clase 05 — Introducción a NumPy:** arrays, operaciones, reshape.  
06. **Clase 06 — Introducción a pandas:** DataFrames, filtrado, limpieza.  
07. **Clase 07 — Visualización con matplotlib y seaborn.**  
08. **Clase 08 — PROYECTO MINI:** análisis exploratorio de dataset de películas.  
09. **Clase 09 — Preprocesamiento de datos:** nulos, escalado, codificación.  
10. **Clase 10 — Dataset real:** limpieza y preparación completa.  
11. **Clase 11 — División de datos:** train/test, validación cruzada.  
12. **Clase 12 — Primer modelo de regresión lineal (scikit-learn).**  
13. **Clase 13 — Evaluación de regresión:** MAE, MSE, R².  
14. **Clase 14 — Primer modelo de clasificación (árbol de decisión).**  
15. **Clase 15 — Evaluación de clasificación:** accuracy, matriz de confusión, precision/recall.  
16. **Clase 16 — PROYECTO MINI:** clasificación de correos spam/no spam.  
17. **Clase 17 — Algoritmos de clustering:** K-Means.  
18. **Clase 18 — PROYECTO:** agrupar usuarios por comportamiento de compra.  
19. **Clase 19 — Algoritmos avanzados:** Random Forest, SVM.  
20. **Clase 20 — Pipeline de ML con scikit-learn:** end-to-end.  
21. **Clase 21 — PROYECTO:** predicción de precios de viviendas.  
22. **Clase 22 — Introducción a redes neuronales con TensorFlow/Keras.**  
23. **Clase 23 — Crear y entrenar red neuronal simple:** dense, relu, softmax.  
24. **Clase 24 — PROYECTO:** clasificación de imágenes con MNIST.  
25. **Clase 25 — Entrenamiento, validación, overfitting y regularización.**  
26. **Clase 26 — Guardar y reutilizar modelos entrenados.**  
27. **Clase 27 — Integrar modelo entrenado a API con FastAPI.**  
28. **Clase 28 — PROYECTO MINI:** API que clasifica textos o imágenes.  
29. **Clase 29 — ¿Qué sigue después?:** ML Ops, deep learning, NLP, visión.  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** proyecto completo con dataset real. Carga, limpieza, entrenamiento, evaluación, API funcional.

---

## 🟫 MÓDULO 10 — Desarrollo de aplicaciones móviles y de escritorio (Versión extendida)

**OBJETIVO:** Crear apps funcionales y multiplataforma usando frameworks modernos para desktop (Electron/Tauri) y móvil (Flutter/React Native).

*Clases:*  
01. **Clase 01 — ¿Qué es una app nativa, híbrida y PWA?**  
02. **Clase 02 — Elección de framework:** desktop vs móvil.  
03. **Clase 03 — Introducción a Tauri:** qué es y por qué es ligero.  
04. **Clase 04 — Instalación de entorno para Tauri + frontend.**  
05. **Clase 05 — Primer proyecto Tauri:** app de notas simple.  
06. **Clase 06 — Comunicación entre frontend y backend en Tauri.**  
07. **Clase 07 — Guardado de archivos locales desde escritorio.**  
08. **Clase 08 — Estilo de apps con CSS y JS en escritorio.**  
09. **Clase 09 — PROYECTO MINI:** Calculadora contable multiplataforma.  
10. **Clase 10 — Compilar app para Windows/Linux/Mac.**  
11. **Clase 11 — Introducción a Flutter:** qué es y por qué usarlo.  
12. **Clase 12 — Instalación y configuración de Flutter + Android Studio.**  
13. **Clase 13 — Estructura de un proyecto Flutter (Dart).**  
14. **Clase 14 — Widgets, scaffold, columnas, filas, texto, imagen.**  
15. **Clase 15 — Navegación entre pantallas y rutas.**  
16. **Clase 16 — PROYECTO MINI:** App de registro de gastos personales.  
17. **Clase 17 — Uso de formularios y validación de entradas.**  
18. **Clase 18 — Guardado local con shared_preferences o SQLite.**  
19. **Clase 19 — Integrar API externa (HTTP package).**  
20. **Clase 20 — Manejo de estado con setState y provider.**  
21. **Clase 21 — PROYECTO COMPLETO:** App de clientes con backend FastAPI.  
22. **Clase 22 — Autenticación con tokens en móvil.**  
23. **Clase 23 — Push notifications (Firebase básico).**  
24. **Clase 24 — Compilar y probar en Android/iOS emulador.**  
25. **Clase 25 — Publicación en Google Play Store (simulada).**  
26. **Clase 26 — Publicación de apps de escritorio instalables.**  
27. **Clase 27 — Crear interfaz atractiva y profesional (UI/UX).**  
28. **Clase 28 — Soporte multilenguaje y localización.**  
29. **Clase 29 — Exportar datos desde app a PDF/Excel (cliente).**  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** App móvil o desktop con backend integrado. Funcional, compilada, con persistencia y API externa.

---

## 🟥 MÓDULO 11 — Proyecto Final de Integración (Versión extendida)

**OBJETIVO:** Construir una aplicación completa, profesional, con frontend, backend, base de datos, despliegue y documentación. Será tu carta de presentación al mundo real.

*Clases:*  
01. **Clase 01 — Definición del proyecto:** elección del problema real a resolver (Ejemplos: sistema de reservas, gestión escolar, facturación).  
02. **Clase 02 — Análisis de requerimientos funcionales y técnicos.**  
03. **Clase 03 — Diseño de la arquitectura general:** modular, escalable.  
04. **Clase 04 — Elección del stack:** FastAPI + React + PostgreSQL (editable).  
05. **Clase 05 — Diseño de base de datos completo:** modelo entidad-relación.  
06. **Clase 06 — Configuración de entorno de desarrollo:** repos, branches, Docker.  
07. **Clase 07 — Desarrollo de backend:** autenticación, usuarios, roles.  
08. **Clase 08 — Endpoints base:** CRUD de entidad principal (ej. productos, clientes).  
09. **Clase 09 — Rutas protegidas y verificación por rol.**  
10. **Clase 10 — Integración de servicios externos:** API o email.  
11. **Clase 11 — Desarrollo de frontend:** layout base y navegación.  
12. **Clase 12 — Conexión a backend con Fetch/Axios.**  
13. **Clase 13 — Componentes reutilizables:** formularios, tablas, modales.  
14. **Clase 14 — Validación de datos:** cliente y servidor.  
15. **Clase 15 — Manejo de errores global.**  
16. **Clase 16 — Estilo profesional:** CSS limpio, responsive, branding personalizado.  
17. **Clase 17 — Módulo de autenticación en frontend:** login, logout, registro.  
18. **Clase 18 — Guardado de datos relacionados:** cliente + historial.  
19. **Clase 19 — Generación de reportes:** PDF/Excel.  
20. **Clase 20 — Subida y gestión de archivos adjuntos.**  
21. **Clase 21 — Panel de administración:** control de usuarios, datos y registros.  
22. **Clase 22 — Logs de auditoría y actividad de usuario.**  
23. **Clase 23 — Testing:** pruebas unitarias y funcionales (pytest + React Testing Library).  
24. **Clase 24 — CI/CD con GitHub Actions:** tests + despliegue.  
25. **Clase 25 — Configuración de dominio personalizado + HTTPS.**  
26. **Clase 26 — Preparación para cliente o demo final.**  
27. **Clase 27 — Documentación completa del proyecto:** README, arquitectura, endpoints.  
28. **Clase 28 — Simulación de presentación a cliente:** pitch + demo.  
29. **Clase 29 — Publicación en GitHub como portafolio profesional.**  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** proyecto 100% funcional, documentado y publicado. Mínimo 7/10. Feedback detallado sobre calidad, código, diseño y escalabilidad.

---

## 🟪 MÓDULO 12 — Estructuras de datos y algoritmos clásicos (Versión extendida)

**OBJETIVO:** Dominar estructuras clave (listas, árboles, grafos) y algoritmos típicos para mejorar tu pensamiento lógico y preparación para entrevistas técnicas.

*Clases:*  
01. **Clase 01 — Qué es un algoritmo y cómo medir su eficiencia (Big O).**  
02. **Clase 02 — Listas, pilas y colas:** implementación manual y con colecciones.  
03. **Clase 03 — Proyecto:** simulador de historial de navegador (con pila).  
04. **Clase 04 — Recursividad paso a paso:** visualización y trampas comunes.  
05. **Clase 05 — Algoritmos de búsqueda:** lineal y binaria.  
06. **Clase 06 — Proyecto:** buscador en lista de productos ordenados.  
07. **Clase 07 — Algoritmos de ordenamiento:** bubble, insertion, selection.  
08. **Clase 08 — Merge sort y quicksort (explicado gráficamente).**  
09. **Clase 09 — Proyecto:** ordenar y filtrar productos por múltiples criterios.  
10. **Clase 10 — Sets y diccionarios:** teoría y práctica avanzada.  
11. **Clase 11 — Algoritmos con diccionarios:** conteo de ocurrencias, agrupamientos.  
12. **Clase 12 — Árboles binarios:** concepto, recorrido DFS y BFS.  
13. **Clase 13 — Proyecto:** árbol de categorías con búsqueda anidada.  
14. **Clase 14 — Grafos:** nodos, aristas, representaciones.  
15. **Clase 15 — Algoritmo de Dijkstra:** rutas mínimas.  
16. **Clase 16 — Proyecto:** mapa de rutas entre ciudades con pesos.  
17. **Clase 17 — Programación dinámica:** idea, casos famosos (Fibonacci, mochila).  
18. **Clase 18 — Backtracking:** sudoku, laberintos, combinaciones.  
19. **Clase 19 — Proyecto:** generador de combinaciones de contraseñas seguras.  
20. **Clase 20 — Algoritmos de hashing y funciones hash.**  
21. **Clase 21 — Tabla hash:** colisiones y manejo.  
22. **Clase 22 — Uso de algoritmos en IA y optimización.**  
23. **Clase 23 — Desafíos estilo entrevistas:** leetcode básicos en Python.  
24. **Clase 24 — Preparación para coding interviews:** sistema de tiempo y presión.  
25. **Clase 25 — Proyecto:** analizador de logs con estructura eficiente.  
26. **Clase 26 — Algoritmo de compresión básico:** run-length encoding.  
27. **Clase 27 — Simulación de pila de ejecución:** visualizador recursivo.  
28. **Clase 28 — Estructura de árbol invertido (trie).**  
29. **Clase 29 — Repaso general con desafíos mixtos.**  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** algoritmo aplicado + estructura personalizada.

---

## 🟥 MÓDULO 13 — Seguridad y buenas prácticas avanzadas (Versión extendida)

**OBJETIVO:** Aprender a escribir código seguro, prevenir ataques comunes y aplicar buenas prácticas a nivel profesional.

*Clases:*  
01. **Clase 01 — ¿Qué es la seguridad en el desarrollo de software?**  
02. **Clase 02 — Seguridad en APIs:** autenticación, tokens, scopes.  
03. **Clase 03 — Encriptación vs hashing:** diferencias y casos de uso.  
04. **Clase 04 — Hash de contraseñas con bcrypt/scrypt.**  
05. **Clase 05 — Proyecto:** registro y login seguro con token y hash.  
06. **Clase 06 — Ataques comunes:** XSS, CSRF, SQL Injection.  
07. **Clase 07 — Prevención de inyecciones:** parametrización de consultas.  
08. **Clase 08 — Validación de entradas del usuario (client/server).**  
09. **Clase 09 — Gestión de errores sin revelar datos sensibles.**  
10. **Clase 10 — Protección de rutas y accesos por roles.**  
11. **Clase 11 — Seguridad en frontend:** sanitización y escapes.  
12. **Clase 12 — Seguridad en backend:** control de cabeceras y respuestas.  
13. **Clase 13 — Uso de HTTPS y certificados SSL (Let's Encrypt).**  
14. **Clase 14 — Proyecto:** API con endpoints públicos y privados seguros.  
15. **Clase 15 — Autenticación con OAuth2 y Google/Facebook login.**  
16. **Clase 16 — Seguridad en apps móviles:** almacenamiento local seguro.  
17. **Clase 17 — Buenas prácticas de gestión de secretos (.env, Vault).**  
18. **Clase 18 — Logs seguros y auditorías (evitar datos personales).**  
19. **Clase 19 — Protección de archivos y carpetas sensibles.**  
20. **Clase 20 — Autenticación multifactor (2FA).**  
21. **Clase 21 — Control de sesiones:** expiración, renovación, token refresh.  
22. **Clase 22 — Principios de mínimos privilegios.**  
23. **Clase 23 — Seguridad en despliegues:** puertos, acceso SSH.  
24. **Clase 24 — Simulación de pentest básico en tu propia API.**  
25. **Clase 25 — Monitoreo de ataques o uso indebido:** logs + alertas.  
26. **Clase 26 — Revisión de dependencias inseguras (Snyk, pip-audit).**  
27. **Clase 27 — Introducción a seguridad en CI/CD.**  
28. **Clase 28 — Auditoría de código antes de producción.**  
29. **Clase 29 — Proyecto final:** app segura con backend y frontend blindado.  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** checklist de seguridad + revisión de código.

## 🟦 MÓDULO 14 — Testing y calidad de software (Versión extendida)

**OBJETIVO:** Aprender a testear tu código con pruebas unitarias, funcionales, de integración y automatizadas. Garantizar calidad y robustez.

*Clases:*  
01. **Clase 01 — ¿Qué es testing y por qué es esencial?**  
02. **Clase 02 — Tipos de pruebas:** unitarias, integración, extremo a extremo.  
03. **Clase 03 — Escribir pruebas simples con assert en Python.**  
04. **Clase 04 — Introducción a unittest y estructura básica de tests.**  
05. **Clase 05 — Uso de pytest:** sintaxis limpia, fixtures, marcadores.  
06. **Clase 06 — Proyecto mini:** testear funciones matemáticas y de texto.  
07. **Clase 07 — TDD:** desarrollo guiado por pruebas (Test Driven Development).  
08. **Clase 08 — Pruebas de clases y objetos (POO).**  
09. **Clase 09 — Simulación de errores y excepciones en tests.**  
10. **Clase 10 — Cobertura de tests con coverage.py.**  
11. **Clase 11 — Pruebas de APIs con requests y pytest.**  
12. **Clase 12 — Proyecto:** tests para una API de productos.  
13. **Clase 13 — Mocks y testeo de funciones externas (patching).**  
14. **Clase 14 — Testear subida de archivos, login, headers.**  
15. **Clase 15 — Automatización de tests con CI (GitHub Actions).**  
16. **Clase 16 — Validación automática en cada push/pull request.**  
17. **Clase 17 — Pruebas con base de datos:** uso de test DB.  
18. **Clase 18 — Creación de datos de prueba y limpieza automática.**  
19. **Clase 19 — Pruebas de frontend con React Testing Library.**  
20. **Clase 20 — Proyecto:** testear flujo de login y dashboard React.  
21. **Clase 21 — Cypress para tests E2E:** instalación y primeros tests.  
22. **Clase 22 — Testear formularios, navegación, filtros.**  
23. **Clase 23 — Screenshots automáticos de fallos en tests.**  
24. **Clase 24 — Integración de Cypress en CI/CD.**  
25. **Clase 25 — Indicadores de calidad del software (SonarQube básico).**  
26. **Clase 26 — Definición de estándares y reglas internas de código.**  
27. **Clase 27 — Checklist de calidad antes de producción.**  
28. **Clase 28 — Análisis estático con linters y formatters.**  
29. **Clase 29 — Proyecto final:** suite de tests completa (API + Frontend).  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** 100% cobertura + flujo automatizado.

## 🟧 MÓDULO 15 — Monetización y carrera como programador freelance (Versión extendida)

**OBJETIVO:** Aprender a generar ingresos como programador independiente, crear tu marca, trabajar con clientes y vender soluciones.

*Clases:*  
01. **Clase 01 — ¿Cómo ganar dinero como programador hoy?**  
02. **Clase 02 — Freelancing vs trabajar en empresa.**  
03. **Clase 03 — Plataformas para conseguir clientes:** Upwork, Fiverr, Malt, Workana.  
04. **Clase 04 — Crear un perfil atractivo y profesional.**  
05. **Clase 05 — Cómo armar un portafolio que vende:** GitHub, demo online, PDF.  
06. **Clase 06 — Comunicación con clientes:** propuestas y alcance.  
07. **Clase 07 — Plantilla de contrato y NDA básico.**  
08. **Clase 08 — Gestión de proyectos:** herramientas y metodologías (Trello, Notion, Scrum).  
09. **Clase 09 — Precios, tarifas y presupuestos:** cómo cobrar bien.  
10. **Clase 10 — Imprevistos:** cómo manejarlos sin perder al cliente.  
11. **Clase 11 — Nichos de mercado rentables:** ecommerce, automatización, scraping, etc.  
12. **Clase 12 — Proyecto:** app freelance para un cliente ficticio real.  
13. **Clase 13 — Cómo presentar tus servicios y tu proceso.**  
14. **Clase 14 — Crear una página web profesional:** landing + portafolio.  
15. **Clase 15 — Automatizar tu propio flujo:** facturas, reportes, alertas.  
16. **Clase 16 — SEO básico para atraer clientes orgánicos.**  
17. **Clase 17 — Usar LinkedIn como programador proactivo.**  
18. **Clase 18 — YouTube, TikTok, Blog:** estrategias si quieres enseñar o vender cursos.  
19. **Clase 19 — Convertir tus scripts en productos:** plantillas, licencias, apps vendibles.  
20. **Clase 20 — Proyecto:** script automatizado como producto digital.  
21. **Clase 21 — Licencias de software:** GPL, MIT, privada.  
22. **Clase 22 — Crear comunidad:** Discord, canal privado, mailing.  
23. **Clase 23 — Construir autoridad:** contribuciones open source y charlas.  
24. **Clase 24 — Cobros internacionales:** Payoneer, Wise, criptomonedas.  
25. **Clase 25 — Protección legal básica:** responsabilidad, políticas.  
26. **Clase 26 — Escalar:** contratar ayuda, tercerizar, automatizar tu negocio.  
27. **Clase 27 — Crear una agencia o equipo remoto.**  
28. **Clase 28 — Finanzas para programadores freelance.**  
29. **Clase 29 — Plan personal a 1 año:** objetivos, hitos, métricas.  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** propuesta real, portafolio completo y estrategia a 6 meses.

---

⚠️ **NOTA IMPORTANTE:**  
Luego del Módulo 15 haremos una **pequeña pausa** para integrar un **MÓDULO INTENSIVO – JSON**.  
Una vez concluido este módulo especial, continuaremos con el **MÓDULO 16** siguiendo el plan oficial del curso.

## ⬛ MÓDULO INTENSIVO – JSON

**OBJETIVO:** Comprender a fondo el formato JSON y su uso práctico en proyectos reales con Python y JavaScript. Aprenderás a leer, escribir, validar y manipular datos en formato JSON para integrarlo en sistemas, APIs y almacenamiento de información persistente.

*Clases:*  
01. **Clase 01 — ¿Qué es JSON y para qué sirve?**  
02. **Clase 02 — Estructura básica de un archivo JSON**  
03. **Clase 03 — Tipos de datos permitidos en JSON**  
04. **Clase 04 — Diferencias entre JSON, CSV, XML y otros formatos**  
05. **Clase 05 — Cómo validar un archivo JSON:** herramientas y buenas prácticas.  
06. **Clase 06 — Introducción al módulo `json` en Python**  
07. **Clase 07 — `json.dumps()`: convertir diccionario a texto JSON**  
08. **Clase 08 — `json.loads()`: convertir texto JSON a diccionario**  
09. **Clase 09 — `json.dump()`: guardar JSON directamente en un archivo**  
10. **Clase 10 — `json.load()`: cargar JSON desde archivo**  
11. **Clase 11 — Opciones avanzadas:** indentación, ordenamiento, `ensure_ascii`.  
12. **Clase 12 — `JSON.stringify()` en JavaScript**  
13. **Clase 13 — `JSON.parse()`: convertir texto a objeto JS**  
14. **Clase 14 — Validar y manejar errores al parsear**  
15. **Clase 15 — Simular una API con un archivo JSON local y `fetch()`**  
16. **Clase 16 — Recorrer datos JSON anidados (Python y JS)**  
17. **Clase 17 — Proyecto Python:** sistema de usuarios persistente con JSON.  
18. **Clase 18 — Proyecto JS:** página que muestra contenido cargado desde un archivo `.json`.  
19. **Clase 19 — Guardar datos en `localStorage` como JSON (JS)**  
20. **Clase 20 — Convertir entre JSON y otros formatos:** CSV, diccionario, objeto, etc.

## 🟩 MÓDULO 16: Blockchain y contratos inteligentes — Versión extendida

**OBJETIVO:** Comprender el funcionamiento de las cadenas de bloques, desarrollar y desplegar contratos inteligentes en Ethereum con Solidity.

*Clases:*
01. ¿Qué es Blockchain y cómo funciona?  
02. Historia y casos de uso reales (más allá de criptomonedas)  
03. Qué es un contrato inteligente  
04. Ethereum, EVM y red descentralizada  
05. Instalación de entorno: Node.js, Metamask, Hardhat  
06. Crear wallet y usar testnets (Goerli, Sepolia)  
07. Ethers, gas, fees: conceptos clave  
08. Primer contrato inteligente en Solidity  
09. Tipos de datos en Solidity: `uint`, `string`, `mapping`, `address`  
10. Funciones públicas, privadas y eventos  
11. Modificadores y control de acceso (`onlyOwner`, `require`)  
12. Proyecto: contrato de registro de usuarios en blockchain  
13. Deploy local con Hardhat + pruebas automáticas  
14. Interacción con contratos desde scripts JS  
15. Introducción a Web3.js y Ethers.js  
16. Proyecto: app frontend que interactúa con contrato (dApp)  
17. Enviar y recibir tokens en contrato  
18. Crear un token ERC-20 personalizado  
19. Proyecto: token básico con nombre, símbolo y supply fijo  
20. NFT y ERC-721: tokens únicos  
21. Proyecto: mint de NFT con metadata personalizada  
22. Interfaz de usuario para mintear y ver NFT  
23. Seguridad en contratos: reentrancy, overflow  
24. Uso de OpenZeppelin y librerías auditadas  
25. Simulación de hack: cómo evitar fallas  
26. Deploy en testnet (Goerli) y verificación en Etherscan  
27. Uso de IPFS para archivos descentralizados  
28. Proyecto completo: marketplace NFT básico  
29. Rutas para monetizar: colecciones, tokens, freelance blockchain  
30. 📘 **Evaluación final:** contrato + dApp funcionando en testnet

---

## 🟫 MÓDULO 17: Aplicaciones en tiempo real y WebSockets — Versión extendida

**OBJETIVO:** Crear apps que respondan en tiempo real como chats, notificaciones, dashboards, usando WebSockets y tecnología en vivo.

*Clases:*
01. ¿Qué es una app en tiempo real? Casos de uso  
02. HTTP vs WebSocket: diferencias clave  
03. Instalación de entorno: FastAPI con websockets o Socket.IO  
04. Primer ejemplo de conexión cliente-servidor WebSocket  
05. Eventos, mensajes y canales básicos  
06. Crear servidor de chat mínimo en FastAPI  
07. Conectar cliente web con JS (WebSocket API)  
08. Proyecto mini: chat grupal en navegador  
09. Manejo de múltiples clientes y sesiones activas  
10. Identificación de usuarios (user ID, nickname)  
11. Proyecto: sistema de notificaciones en tiempo real (alertas)  
12. Tablero en vivo: enviar datos desde servidor al frontend  
13. Dashboard reactivo con React y Socket.IO  
14. Guardar mensajes/eventos en base de datos  
15. Proyecto: chat con historial persistente y usuarios  
16. Control de conexión y reconexión automática  
17. Latencia y rendimiento: cómo medirlo  
18. Seguridad básica: tokens en tiempo real (JWT)  
19. Escalabilidad: broadcast, canales, salas privadas  
20. Proyecto: app colaborativa en vivo (lista compartida)  
21. Códigos de estado y manejo de errores  
22. Streaming de datos en tiempo real (simulación de bolsa)  
23. Webhooks vs WebSockets  
24. Uso con APIs externas (Binance, Crypto, Trading)  
25. Proyecto: monitor de precios con WebSocket de Binance  
26. Integración en apps existentes: notificaciones internas  
27. Push notifications (Firebase o Web Push)  
28. Control de usuarios conectados (dashboard admin)  
29. Proyecto final: plataforma con chat, alertas y tablero vivo  
30. 📘 **Evaluación final:** app reactiva y funcional + documentación

---

## 🟥 MÓDULO 18 — Microservicios y Arquitectura Escalable (Versión extendida)

**OBJETIVO:** Entender y construir sistemas distribuidos con microservicios, comunicación entre servicios y escalabilidad.

**Clases:**

1. **Clase 01 —** ¿Qué es una arquitectura de microservicios?  
2. **Clase 02 —** Monolito vs microservicio: diferencias reales  
3. **Clase 03 —** Cuándo conviene usar microservicios  
4. **Clase 04 —** Separar módulos por dominio funcional  
5. **Clase 05 —** FastAPI como microservicio: micro-API de clientes  
6. **Clase 06 —** Segundo servicio: API de productos  
7. **Clase 07 —** Comunicación entre microservicios: REST vs eventos  
8. **Clase 08 —** Uso de RabbitMQ o Redis Pub/Sub para comunicación  
9. **Clase 09 — PROYECTO:** Sistema de pedidos distribuido (cliente, producto, orden)  
10. **Clase 10 —** Docker Compose para múltiples servicios  
11. **Clase 11 —** API Gateway: qué es y para qué sirve  
12. **Clase 12 —** Creación de Gateway simple con FastAPI  
13. **Clase 13 —** Autenticación centralizada (JWT + Gateway)  
14. **Clase 14 —** Base de datos separada por servicio  
15. **Clase 15 — PROYECTO:** Microservicio de pagos simulado  
16. **Clase 16 —** Circuit Breaker y retries automáticos  
17. **Clase 17 —** Observabilidad: logs centralizados y trazabilidad  
18. **Clase 18 —** Uso de Elastic + Kibana (monitoring básico)  
19. **Clase 19 —** Testeo de microservicios individual y conjunto  
20. **Clase 20 —** CI/CD multicomponente (workflow por microservicio)  
21. **Clase 21 —** Escalar servicios de forma independiente  
22. **Clase 22 —** Balanceadores de carga (teoría básica)  
23. **Clase 23 — PROYECTO:** Backend dividido en 3+ servicios  
24. **Clase 24 —** Kubernetes (intro visual, no hands-on)  
25. **Clase 25 —** Migración progresiva de monolito a microservicio  
26. **Clase 26 —** Control de versiones de APIs (v1, v2)  
27. **Clase 27 —** Health checks y readiness endpoints  
28. **Clase 28 —** Buenas prácticas en sistemas distribuidos  
29. **Clase 29 —** Documentación centralizada con Swagger Hub  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** Microapp funcional con 3+ servicios comunicándose

---

## 🟪 MÓDULO 19 — Testing de Carga, Performance y Stress (Versión extendida)

**OBJETIVO:** Aprender a medir el rendimiento de tus apps, detectar cuellos de botella y garantizar que funcionen bajo alta demanda.

**Clases:**

1. **Clase 01 —** ¿Qué es un test de carga, stress y performance?  
2. **Clase 02 —** Herramientas: Locust, Artillery, JMeter (intro)  
3. **Clase 03 —** Instalación y primer script con Locust  
4. **Clase 04 —** Crear usuarios virtuales que simulan tráfico  
5. **Clase 05 —** Definir escenarios realistas: login, compra, lectura  
6. **Clase 06 —** Análisis de resultados: tiempos, errores, tasa de fallos  
7. **Clase 07 — PROYECTO MINI:** Stress test de una API de productos  
8. **Clase 08 —** Test de concurrencia con threads y asyncio  
9. **Clase 09 —** Monitoreo de consumo de memoria y CPU  
10. **Clase 10 —** Optimizar endpoints lentos con profiling  
11. **Clase 11 —** cProfile y line_profiler: identificar cuellos de botella  
12. **Clase 12 —** Optimización de base de datos: índices, EXPLAIN, limitación  
13. **Clase 13 — PROYECTO:** Comparar rendimiento antes y después de optimización  
14. **Clase 14 —** Caching: introducción con functools.lru_cache y Redis  
15. **Clase 15 —** Test de performance en frontend (Lighthouse)  
16. **Clase 16 —** Análisis de carga con herramientas del navegador (DevTools)  
17. **Clase 17 —** Imágenes y assets: compresión y lazy loading  
18. **Clase 18 —** API paginada vs carga masiva: impacto en usuarios  
19. **Clase 19 —** Test de tiempo real: WebSocket bajo carga  
20. **Clase 20 — PROYECTO:** Simular 500 usuarios en chat simultáneo  
21. **Clase 21 —** Establecer umbrales de rendimiento aceptables  
22. **Clase 22 —** Alertas automáticas cuando rendimiento cae  
23. **Clase 23 —** Despliegue escalado: horizontal vs vertical  
24. **Clase 24 —** Uso de CDN para frontend  
25. **Clase 25 —** Escenarios catastróficos: caída de servicio controlada  
26. **Clase 26 —** Documentar pruebas y recomendaciones por endpoint  
27. **Clase 27 —** Test automático de rendimiento en cada build (CI/CD)  
28. **Clase 28 —** Comparación de frameworks por rendimiento  
29. **Clase 29 — PROYECTO FINAL:** App backend + frontend optimizada con pruebas documentadas  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** Stress test + plan de optimización entregado

---

---

## 🟥 MÓDULO 20 — Diseño UX/UI profesional (Versión extendida)

**OBJETIVO:** Diseñar interfaces limpias, agradables y usables, usando Figma, principios de UX y prototipado profesional.

**Clases:**

1. **Clase 01 —** ¿Qué es UX y UI? Diferencias y sinergias  
2. **Clase 02 —** Principios de diseño centrado en el usuario  
3. **Clase 03 —** Introducción a Figma y su interfaz  
4. **Clase 04 —** Crear tu primer frame y wireframe básico  
5. **Clase 05 —** Componentes reutilizables en Figma (buttons, cards)  
6. **Clase 06 —** Tipografía web: jerarquías, tamaños y espaciado  
7. **Clase 07 —** Paletas de colores accesibles y armónicas  
8. **Clase 08 —** Contraste, visibilidad y accesibilidad (WCAG)  
9. **Clase 09 —** Diseño mobile-first vs desktop-first  
10. **Clase 10 —** Grillas y diseño responsivo en diseño visual  
11. **Clase 11 — PROYECTO MINI:** Landing page para app ficticia  
12. **Clase 12 —** Uso de iconografía (Material Icons, FontAwesome)  
13. **Clase 13 —** Buenas prácticas en formularios y entradas  
14. **Clase 14 —** UX writing: microtextos que guían al usuario  
15. **Clase 15 —** Animaciones UX: cuándo, cómo y por qué usarlas  
16. **Clase 16 —** Prototipado en Figma (interacción entre pantallas)  
17. **Clase 17 — PROYECTO:** Prototipo navegable de app completa  
18. **Clase 18 —** Test de usabilidad: feedback de usuarios  
19. **Clase 19 —** Cómo presentar tu diseño a un cliente o equipo  
20. **Clase 20 —** Adaptar diseño para React, Flutter y HTML  
21. **Clase 21 —** Design systems: qué son y cómo usarlos  
22. **Clase 22 —** UI Kits: Material Design, Tailwind UI, Bootstrap UI  
23. **Clase 23 —** Exportar assets y código desde Figma  
24. **Clase 24 —** Adaptación a modo oscuro (dark mode)  
25. **Clase 25 — PROYECTO FINAL:** Dashboard completo con UI profesional  
26. **Clase 26 —** Introducción a motion design (principios básicos)  
27. **Clase 27 —** Herramientas extra: Adobe XD, Framer, Penpot  
28. **Clase 28 —** UX en apps empresariales vs apps personales  
29. **Clase 29 —** Portafolio de diseño en Behance, Dribbble, GitHub Pages  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** Prototipo navegable + presentación documentada

---

## 🏁 MÓDULO 21 — Desarrollo de videojuegos 2D con Python (Pygame) (Versión extendida)

**OBJETIVO:** Aprender los fundamentos del desarrollo de juegos 2D usando Pygame, lógica de movimiento, colisiones, enemigos, sonido y más.

**Clases:**

1. **Clase 01 —** Introducción al desarrollo de juegos  
2. **Clase 02 —** Instalación y estructura base de Pygame  
3. **Clase 03 —** Crear una ventana de juego y bucle principal  
4. **Clase 04 —** Mostrar texto, imágenes y formas simples  
5. **Clase 05 —** Capturar eventos de teclado y mouse  
6. **Clase 06 —** Movimiento del jugador con teclas  
7. **Clase 07 —** Control de velocidad y FPS  
8. **Clase 08 —** Animaciones con sprites  
9. **Clase 09 —** Colisiones entre objetos  
10. **Clase 10 — PROYECTO:** Mini juego de esquivar obstáculos  
11. **Clase 11 —** Agregar fondo y scroll infinito  
12. **Clase 12 —** Música y efectos de sonido (pygame.mixer)  
13. **Clase 13 —** Enemigos que se mueven con lógica  
14. **Clase 14 —** Sistema de puntuación y vidas  
15. **Clase 15 —** Pantalla de inicio y pantalla de Game Over  
16. **Clase 16 —** Guardado de puntajes altos en archivo  
17. **Clase 17 —** Niveles y dificultad progresiva  
18. **Clase 18 —** Disparos, armas y objetos recogibles  
19. **Clase 19 —** IA básica para enemigos  
20. **Clase 20 —** Menús interactivos con opciones  
21. **Clase 21 — PROYECTO:** Juego completo tipo "arcade shooter"  
22. **Clase 22 —** Empaquetar juego como ejecutable (Windows/Linux)  
23. **Clase 23 —** Crear íconos y branding de tu juego  
24. **Clase 24 —** Optimización de rendimiento en Pygame  
25. **Clase 25 —** Control con joystick (si se desea)  
26. **Clase 26 —** Agregar logros y niveles secretos  
27. **Clase 27 —** Publicar tu juego en Itch.io  
28. **Clase 28 —** Monetización de juegos simples (licencias, anuncios)  
29. **Clase 29 —** Portafolio de juegos: presentación en web + descarga  
30. **Clase 30 — 📘 EVALUACIÓN FINAL:** Juego completo, ejecutable y documentado

---

## 🔲 MÓDULO EXTRA A — Integración entre scripts y módulos

**OBJETIVO:** Aprender a combinar proyectos anteriores en soluciones reales más grandes.

**Clases:**

1. **Clase 01 —** Reutilizar funciones de otros scripts (`import`)  
2. **Clase 02 —** `if __name__ == "__main__":` para ejecución controlada  
3. **Clase 03 —** Guardar datos en `.json` o `.csv` desde múltiples scripts  
4. **Clase 04 — PROYECTO:** “Gestor de tareas + generador de reportes”  
5. **Clase 05 — PRÁCTICA:** Separación por carpetas y módulos reutilizables  
6. **Clase 06 — 📘 EVALUACIÓN:** App modular integrada

---
